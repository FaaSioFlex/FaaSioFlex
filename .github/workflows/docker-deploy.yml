name: Docker CI/CD

on:
  workflow_dispatch: # Permite la ejecución manual del flujo de trabajo
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Check if Dockerfile Exists
        id: check_dockerfile
        run: |
          if [ ! -f Dockerfile ]; then
            echo "Dockerfile not found, exiting." # Comprobar si existe el archivo Dockerfile
            exit 1 # Salir con un código de error si no se encuentra el Dockerfile
          fi

      - name: Build Docker Image
        if: steps.check_dockerfile.outcome == 'success'
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/my-go-app:latest . # Construir la imagen Docker con la etiqueta que incluye el nombre de usuario desde los secretos

      - name: Check if Docker Image Exists
        id: check_image
        run: |
          if ! docker images -q ${{ secrets.DOCKER_USERNAME }}/my-go-app:latest; then
            echo "No Docker image found. No image was built." # Verificar si la imagen Docker se construyó correctamente
            exit 1 # Salir con un código de error si no se encuentra la imagen
          fi
      - name: Login to Docker Hub
        if: steps.check_image.outcome == 'success'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}  
          password: ${{ secrets.DOCKER_PASSWORD }}  

      - name: Push Docker Image
        if: steps.check_image.outcome == 'success'
        run: |
          docker push ${{ secrets.DOCKER_USERNAME }}/my-go-app:latest # Empujar la imagen con el nombre de usuario incluido desde los secretos

  run_in_codespace:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        
      - name: Set up Codespaces environment
        run: |
          set -e  # Detener en el primer error
          
          # Limpieza de la caché y eliminación de listas
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*
          sudo apt-get update
          
          # Comprobar y eliminar containerd si está instalado
          if dpkg -l | grep -q containerd; then
            sudo apt-get remove --purge -y containerd containerd.io || true
            sudo apt-get purge -y containerd || true
            sudo apt-get autoremove -y || true
          fi
          
          # Eliminar cualquier paquete que pueda causar conflictos
          sudo apt-get autoremove -y || true
      - name: Update package list
        run: |
          sudo apt-get update
      - name: Instalar dependencias necesarias
        run: |
          # Instalar dependencias necesarias ; containerd.io
          set -e
          sudo apt-get install -y  docker.io

      - name: Iniciar el servicio Docker
        run: |   
          # Iniciar el servicio Docker
          sudo systemctl start docker || true
          sudo systemctl enable docker || true  # Asegúrate de que Docker se inicie en el arranque
          
          # Agregar el usuario actual al grupo docker (en GitHub Actions, este paso no es necesario)
          # El siguiente comando no tiene efecto, así que se omite
          # sudo usermod -aG docker $USER
  
      - name: Check installed packages
        run: |
          dpkg -l | grep containerd

      - name: Check sources list
        run: |
          cat /etc/apt/sources.list
          ls /etc/apt/sources.list.d/
          
      - name: Fix broken packages
        run: |
          sudo apt-get update
          sudo apt-get upgrade -y
          sudo apt-get install -f
          
      - name: Clean APT cache
        run: |
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*
          sudo apt-get update
          sudo apt-get install -y containerd.io docker.io   
          
      - name: Run Docker container in Codespaces
        run: |
          docker run -d -p 8080:8080 --name my-go-app ${{ secrets.DOCKER_USERNAME }}/my-go-app:latest
         
      - name: Install ngrok
        run: |
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt-get update
          sudo apt-get install -y ngrok

      - name: Run ngrok
        run: |
          nohup ngrok http 8080 > ngrok.log &
          sleep 5
          # Extraer la URL pública de ngrok
          NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r .tunnels[0].public_url)
          echo "La URL pública de ngrok es: $NGROK_URL"
        env:
          NGROK_AUTHTOKEN: ${{ secrets.NGROK_AUTHTOKEN }}
 

      - name: Test the application
        run: |
          # Usar la URL pública para probar
          curl -s "$NGROK_URL" || echo "La aplicación no respondió correctamente"
            - name: Stop and Remove Docker container
              if: always()
              run: |
                docker stop my-go-app
                docker rm my-go-app


  # Despliegue en varias plataformas (comentado)
    #deploy:
    #  runs-on: ubuntu-latest
    #  needs: build

     #steps:
     #   - name: Checkout Code
     #     uses: actions/checkout@v2

      # Despliegue en Fly.io
      # - name: Log in to Fly.io
        # uses: flyctl-actions/login@v1
        # with:
          # api_token: ${{ secrets.FLY_API_TOKEN }}

      # - name: Deploy to Fly.io
       # run: |
          # flyctl deploy --remote-only --app faasioflex

      # Despliegue en Heroku
      #- name: Log in to Heroku
       # run: |
         # echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username _ --password-stdin registry.heroku.com

      #- name: Deploy to Heroku
       # run: |
         # heroku container:push web --app faasioflex
         # heroku container:release web --app faasioflex

      # Despliegue en tu servidor
      # - name: Deploy to Server
       # if: success()
        # run: |
          # ssh user@your-server-ip "docker pull my-go-app:latest && docker run -d my-go-app:latest"

          # Despliegue en Google Cloud Run
      #- name: Set up Google Cloud
         #uses: google-github-actions/setup-gcloud@v0
         #with:
           #version: 'latest'
           #project_id: ${{ secrets.GCP_PROJECT_ID }}
           #service_account_key: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      #- name: Build and Push Docker image to Google Container Registry
         #run: |
           #docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/faasioflex .
           #docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/faasioflex

      #- name: Deploy to Google Cloud Run
           #run: |
             #gcloud run deploy faasioflex \
               #--image gcr.io/${{ secrets.GCP_PROJECT_ID }}/faasioflex \
               #--platform managed \
               #--region us-central1 \
               #--allow-unauthenticated

  # Despliegue en Render
      #- name: Deploy to Render
            #run: |
              #curl -X POST \
              #-H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              #-H "Content-Type: application/json" \
              #--data '{"serviceId": "your-service-id", "branch": "main"}' \
              #https://api.render.com/deploy/svc_your_service_id
