name: Docker CI/CD

on:
  workflow_dispatch: # Permite la ejecución manual del flujo de trabajo
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

steps:
  - name: Checkout Code
    uses: actions/checkout@v3

  - name: Set up Docker Buildx
    uses: docker/setup-buildx-action@v2

  - name: Check if Dockerfile Exists
    id: check_dockerfile
    run: |
      if [ ! -f Dockerfile ]; then
        echo "Dockerfile not found, exiting." # Comprobar si existe el archivo Dockerfile
        exit 1 # Salir con un código de error si no se encuentra el Dockerfile
      fi

  - name: Build Docker Image
    if: steps.check_dockerfile.outcome == 'success'
    run: |
      docker build -t ${{ secrets.DOCKER_USERNAME }}/my-go-app:latest . # Construir la imagen Docker con la etiqueta que incluye el nombre de usuario desde los secretos

  - name: Check if Docker Image Exists
    id: check_image
    run: |
      if ! docker images -q ${{ secrets.DOCKER_USERNAME }}/my-go-app:latest; then
        echo "No Docker image found. No image was built." # Verificar si la imagen Docker se construyó correctamente
        exit 1 # Salir con un código de error si no se encuentra la imagen
      fi

  - name: Login to Docker Hub
    if: steps.check_image.outcome == 'success'
    uses: docker/login-action@v3
    with:
      username: ${{ secrets.DOCKER_USERNAME }}  
      password: ${{ secrets.DOCKER_PASSWORD }}  

  - name: Push Docker Image
    if: steps.check_image.outcome == 'success'
    run: |
      docker push ${{ secrets.DOCKER_USERNAME }}/my-go-app:latest # Empujar la imagen con el nombre de usuario incluido desde los secretos

      #- name: Run Tests
        #if: steps.check_image.outcome == 'success'
        #run: |
          #docker run --rm -p 8080:8080 my-go-app:latest || echo "Error ejecutando la aplicación" # Ejecutar el contenedor y exponer el puerto 8080 para pruebas
  # Job para ejecutar en Codespaces (pruebas)
    run_in_codespace:
    runs-on: ubuntu-latest # Usar el último sistema operativo Ubuntu para el trabajo
    needs: build # Este trabajo depende del trabajo de compilación

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3 # Clonar el código fuente del repositorio

      - name: Set up Codespaces environment
        run: |
          # Configuración para ejecutar Docker en Codespaces
          sudo apt-get update # Actualizar la lista de paquetes
          sudo apt-get install -y docker.io # Instalar Docker en el entorno
          sudo systemctl start docker # Iniciar el servicio de Docker
          sudo usermod -aG docker $USER # Agregar el usuario actual al grupo de Docker

      - name: Run Docker container in Codespaces
        run: |
          # Ejecutar el contenedor en Codespaces
          docker run -d -p 8080:8080 --name my-go-app my-go-app:latest # Ejecutar el contenedor en segundo plano y exponer el puerto 8080
          # Esperar unos segundos para que el contenedor esté listo
          sleep 5 # Pausa de 5 segundos para dar tiempo al contenedor a iniciar
          # Probar si la aplicación responde en el puerto 8080
          curl http://localhost:8080 || echo "La aplicación no respondió correctamente" # Verificar si la aplicación está respondiendo
      - name: Install ngrok # Paso para instalar ngrok en el entorno
        run: |
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null # Importar la clave pública de ngrok
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list # Agregar el repositorio de ngrok
          sudo apt update # Actualizar la lista de paquetes
          sudo apt install -y ngrok # Instalar ngrok

      - name: Run ngrok # Ejecutar ngrok para exponer el puerto 8080
        run: |
          nohup ngrok http 8080 > ngrok.log & # Iniciar ngrok en segundo plano, exponiendo el puerto 8080
          sleep 5 # Pausa para dar tiempo a ngrok a iniciar
          NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | grep -o "https://[0-9a-z\-]*.ngrok.io") # Obtener la URL pública generada por ngrok
          echo "La URL pública de ngrok es: $NGROK_URL" # Imprimir la URL pública en los logs
        env:
          NGROK_AUTHTOKEN: ${{ secrets.NGROK_AUTHTOKEN }} # Token de autenticación para ngrok (debe configurarse como un secreto en el repositorio)

      - name: Stop and Remove Docker container
        if: always() # Ejecutar siempre este paso, incluso si los anteriores fallan
        run: |
          docker stop my-go-app # Detener el contenedor
          docker rm my-go-app # Eliminar el contenedor

  # Despliegue en varias plataformas (comentado)
  deploy:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      # Despliegue en Fly.io
      # - name: Log in to Fly.io
        # uses: flyctl-actions/login@v1
        # with:
          # api_token: ${{ secrets.FLY_API_TOKEN }}

      # - name: Deploy to Fly.io
       # run: |
          # flyctl deploy --remote-only --app faasioflex

      # Despliegue en Heroku
      #- name: Log in to Heroku
       # run: |
         # echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username _ --password-stdin registry.heroku.com

      #- name: Deploy to Heroku
       # run: |
         # heroku container:push web --app faasioflex
         # heroku container:release web --app faasioflex

      # Despliegue en tu servidor
      # - name: Deploy to Server
       # if: success()
        # run: |
          # ssh user@your-server-ip "docker pull my-go-app:latest && docker run -d my-go-app:latest"

          # Despliegue en Google Cloud Run
      #- name: Set up Google Cloud
         #uses: google-github-actions/setup-gcloud@v0
         #with:
           #version: 'latest'
           #project_id: ${{ secrets.GCP_PROJECT_ID }}
           #service_account_key: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      #- name: Build and Push Docker image to Google Container Registry
         #run: |
           #docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/faasioflex .
           #docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/faasioflex

      #- name: Deploy to Google Cloud Run
           #run: |
             #gcloud run deploy faasioflex \
               #--image gcr.io/${{ secrets.GCP_PROJECT_ID }}/faasioflex \
               #--platform managed \
               #--region us-central1 \
               #--allow-unauthenticated

  # Despliegue en Render
      #- name: Deploy to Render
            #run: |
              #curl -X POST \
              #-H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              #-H "Content-Type: application/json" \
              #--data '{"serviceId": "your-service-id", "branch": "main"}' \
              #https://api.render.com/deploy/svc_your_service_id
